# 第7章 查找

## 1.总览

**查找表**：查找表是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以用其他的数据结构来实现。

**动态查找表**：若在查找的同时对表做修改操作（插入删除等）则相应的表称之为动态查找表；否则称之为静态查找表。

**平均查找长度ASL**（查找算法的评价指标）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length）。

**对查找表常进行的3种操作：**
1. 查询某个特定的值是否在表中
2. 插入一个元素
3. 删除一个元素
---
## 2.顺序查找和折半查找

### 2.1 顺序查找

**算法思想**

通过数组下标递增来顺序操作每个元素，返回结果。

**优点**：对数据存储结构没有任何要求。

**缺点**：平均查找长度ASL=n，效率较低。

### 2.2 折半查找

折半查找是一种效率高效的查找方法，但是仅适用于有序的顺序表。

折半查找算法思路：（非递归）

1. 设表长为n、low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值。
2. 初始时，令low=1，high=n，mid=[(low+high)/2]。
3. 让k与mid指向的记录比较；若key==R[mid].key，查找成功；若key<R[mid].key，则high=mid-1;若key>R[mid].key，则low=mid+1；若low>high,则返回0代表元素不存在。代码见[折半查找.cpp](折半查找.cpp)

折半查找的过程可以用判定树来表示，把顺序表中的每个元素查找到所用的查找次数写出来，然后次数为1的作为树的根结点，然后查找次数为2的放到第二层，依次把每个元素放到树中。

查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找失败为从根结点到对应失败结点的父结点的路径上的结点数。每个结点的值均大于其左子结点，均小于其右子结点。
![alt text](https://img-blog.csdnimg.cn/20200427202441822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjczMzQ0Mg==,size_16,color_FFFFFF,t_70)

折半查找的时间复杂度为O(logn)，要求线性表必须具有随机存取的特性，仅适用于顺序存储结构，不适于链式存储结构。

### 2.3 分块查找

分块查找是一种性能介于顺序查找和折半查找之间的一种查找方法。

**算法思想**

1. 将表分成几块，且表或者有序，或者分块有序；即若i < j，则第j块中所有记录的关键字均大于第i块中的最大关键字。（注意在块内元素可以是无序的）。
2. 建立索引表（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。

**查找过程**：首先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。
![alt text](https://img-blog.csdnimg.cn/47f709bfc2084ffe8f944480a906915a.png)

### 2.4 上述三种查找对比
![alt text](https://img-blog.csdnimg.cn/72c32d9944ef463889185f44c3d49e5e.png)

---

## 3.B树

B树，又称**多路平衡查找树**，B树中所有结点的孩子个数的最大值成为B树的**阶**，通常用m表示。

在大多数的平衡查找树（Self-balancing search trees），比如 AVL 树和红黑树，都假设所有的数据放在主存当中。那为什么要使用 B-树呢（或者说为啥要有 B-树呢）？要解释清楚这一点，我们假设我们的数据量达到了亿级别，主存当中根本存储不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是**减少磁盘的 I/O 操作**。

大多数平衡树的操作（查找、插入、删除，最大值、最小值等等）需要O(h)次磁盘访问操作，其中 h 是树的高度。但是对于 B-树而言，树的高度将不再是 O(logn) （其中 n 是树中的结点个数），而是一个我们可控的高度 h（通过调整 B-树中结点所包含的键【你也可以叫做数据库中的索引，本质上就是在磁盘上的一个位置信息】的数目，使得 B-树的高度保持一个较小的值）。

一般而言，B-树的结点所包含的键的数目和磁盘块大小一样，从数个到数千个不等。由于B-树的高度 h 可控（一般远小于 logn），所以与 AVL 树和红黑树相比，B-树的磁盘访问时间将极大地降低。

### 3.1 B树的特性

1. 所有的叶子结点都出现在同一层上，并且不带信息(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。
2. 每个结点包含的关键字个数有上界和下界。用一个被称为 B-树的**最小度数**的固定整数 t ≥ 2 来表示这些界，其中 t 取决于磁盘块的大小：
   1. 除根结点以外的每个结点必须至少有 t - 1 个关键字。因此，除了根结点以外的每个内部结点有 t 个孩子。如果树非空，根结点至少有一个关键字。
   2. 每个结点至多包含 2t - 1 个关键字。
3. 一个包含 x 个关键字的结点有 x + 1 个孩子；
4. 一个结点中的所有关键字升序排列，两个关键字 k~1~ 和 k~2~ 之间的孩子结点的所有关键字 key 在 (k~1~, k~2~) 的范围之内。
5. 与二叉排序树不同， B-树的搜索是从根结点开始，根据结点的孩子树做多路分支选择，而二叉排序树做的是二路分支选择，每一次判断都会进行一次磁盘 I/O 操作。
6. 与其他平很二叉树类似，B-树查找、插入和删除操作的时间复杂度为 O(logn) 量级。
![alt text](https://cdn.acwing.com/media/article/image/2022/02/16/150576_ad9a775d8e-1.png)

### 3.2 B树的查找

B树的查找包含两个基本操作：

1. 在B树中找结点
2. 在结点内找关键字

B树常存储在磁盘上，第一个操作是在磁盘上进行的，后一个查找操作是在内存中进行的。在结点内通常采用顺序查找或折半查找。

（1）将给定值与根结点关键字相比较，如果相等，那么查找成功。
（2）如果，小于Ki，那么下次从以 Ai-1 为根的子树中查找。否则下次从以 Ai+1 为根的子树中查找。
（3）如果，查找到叶子结点，那么查找失败。
![alt text](img/image.png)

例如，在4阶B-树中查找给定值26，首先与根结点上的关键字35比较。因为26<35，所以，由A0找到结点B。因为26>18，再与结点E上的关键字比较，26<27，而该结点的A0子树为失误结点叶子。所以，确定该树中不存在26，查找失败。

### 3.3 B树的插入

在B树中找到插入的位置后，并不能简单地将其添加到终端结点，因为此时可能会导致整棵树不符合B树定义中的要求，插入过程如下：

1. 从根结点开始按照查找的过程确定给定值应插入的结点位置P。
2. 如果，该结点上的关键字个数少于 m - 1 个，则将给定值直接插到该结点上。
3. 如果应插入的结点上，已有 m - 1 个关键字，那么，必须把该结点分裂成两个结点；（P、P’） 。

**分裂的方法是：**

- 取一个新的结点，在插入key后的原结点，从中间位置 m / 2（向上取整）将其中的关键字分为两部分，左部分包含的关键字放在原结点，右部分的关键字放在新结点中，中间位置 m / 2（向上取整）的结点插入原结点的父节点。

- 如果此时导致父结点的关键字个数也超过了上限，继续进行这种分裂，直到传递到根节点位置。

**举例如下：**
![alt text](img/B树.png)

### 3.4 B树的删除

B树的删除操作与插入类似，但是复杂一些，因为可能涉及结点的合并。

---
## 4.B+树

B+树是应数据库所需出现的一种B树的变形树。

一棵m阶的B+树和m阶的B-树的差异在于:

1. 有n棵子树的结点中含有n个关键字。
2. 所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点）中的最大（或最小）关键字。

![alt text](https://ts1.cn.mm.bing.net/th/id/R-C.fd4e3f2d62108717948e2da04c4711a5?rik=c96a3k0WlXaoUA&riu=http%3a%2f%2fpicture-pool.oss-cn-beijing.aliyuncs.com%2f2019-05-30-044400.png&ehk=qNgFmNlml668IfAuXQdOLMYoBVxKVSwdeiVBzufDg6U%3d&risl=&pid=ImgRaw&r=0)

可以看出，分支结点的某个关键字是其子树中最大关键字的副本。通常在B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶结点。

因此，可以对B+树进行两种查找运算：
1. 从最小关键字开始的顺序查找
2. 从根节点开始的多路查找

为什么数据库不适用哈希索引？
- 因为数据库查找中通常有很多范围查找，但是哈希值是无序的，所以不能使用。

---
## 5.散列表

前面讨论的线性表、树表结构的查找方法，这类查找方法都是以关键字的比较为基础的。而散列表的思想是通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。

散列函数和散列地址：在记录的存储位置p和其关键字key之间建立一个确定的对应的关系H，使p=H(key)，称这个对应关系H为散列函数，p为散列地址。

散列方法（杂凑法）：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比对，确定查找是否成功。

散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

冲突和同义词：对不同的关键字可能得到同一散列地址，即key1!=key2，而H(key1) = H(key2)，这种现象称为冲突。具有相同函数值的关键对该散列函数来说称作同义词，key1与key2互称为同义词(冲突是不可避免的，我们只能尽可能减少)。

### 5.1 散列函数的构造方法

在构造散列函数时，必须注意以下几点：

1. 构造好的散列函数，所选函数尽可能简单，以便提高转换速度。
2. 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。
3. 制定一个好的解决冲突的方案，查找时如果从散列函数计算出的地址查不到关键码，则应当依据解决冲突的规则，有规律的查询其它相关单元。

#### 5.1.1 直接定址法
直接取关键字的某个线性函数值为散列地址，散列函数为H(key) = a × key + b。

![alt text](https://img-blog.csdnimg.cn/20200504114709427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MTQ5MDYy,size_16,color_FFFFFF,t_70)

这类函数计算简单，分布均匀，不会产生冲突，但要求地址集合与关键词集合大小相同，因此，对于较大的关键词集合不适用。所以在现实应用中并不常用。

#### 5.1.2 除留余数法
现实应用中比较常用的方法是除留取余法。假设散列表长为TableSize（TableSize的选取，通常由关键词集合的大小n和允许最大装填因子α决定，一般将TableSize取为 n / α ）,选择一个正整数p<=TableSize，散列函数为：

``` shell
h(key) = key mod p
```

即取关键词除以p的余数作为散列地址。使用除留取余法，选取合适的p很重要，一般选取p为小于或等于散列表长TableSize的某个最大素数比较好。

用素数求得的余数作为散列地址，比较均匀分布在整个地址空间上的可能性较大。

![alt text](https://img-blog.csdnimg.cn/20200504114953419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MTQ5MDYy,size_16,color_FFFFFF,t_70)

#### 5.1.3 数字分析法
设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，此时应选取数码分布较均匀的若干位作为散列地址。

![alt text](img/数字分析法.png)