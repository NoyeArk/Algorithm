# 115. 不同的子序列

> **作者:** 弘树
> **版本:** 0.1
> **日期:** 2024-08-03
> **版权:** Copyright (c) 2024
> **所用时间:** 17min

### 解题思路

一开始自己做的时候其实是不会的，但是分析的思路如下：

首先观察题目所给的数据范围是$10^3$，所以状态表示应该是一个二维的，如果是二维的话考虑是区间DP，但是区间的话如果进行状态转移呢？

1. $f[i][j]$表示区间$[i, j]$内字符串t出现的次数，但是这种表示太不方便计算了，感觉不对
2. 想不出来$f[i][j]$还有什么状态表示了

### 1.动态规划

状态表示：$f[i][j]$表示s中$[i:n]$个字符和t中$[j:m]$个字符匹配的个数

状态计算：

1. $s[i] = t[j]$：

$$
	f[i][j] = f[i + 1][j + 1] + f[i + 1][j]
$$

2. $s[i] \neq t[j]$：

$$
	f[i][j] = f[i + 1][j]
$$

通过正确的做法可以看出，一开始分析的状态表示是正确的，但是本题不是区间dp，主要这题很难想，因为之前从没做过从大到小进行计算的动态规划，以后又多了一种思路吧：状态计算不一定从小到达，也可以从大到小。

- 时间复杂度：$O(nm)$
- 空间复杂度：$O(nm)$

```C++
class Solution {
public:
    int f[1010][1010];
    const int mod = 1e9 + 7;

    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        if (n < m) return 0;

        for (int i = 0; i <= n; i ++) f[i][m] = 1;
        for (int i = n - 1; ~i; i --)
            for (int j = m - 1; ~j; j --)
            {
                if (s[i] == t[j]) f[i][j] = f[i + 1][j + 1] + f[i + 1][j];
                else f[i][j] = f[i + 1][j];
                f[i][j] %= mod;
            }
        return f[0][0] % mod;
    }
};
```