# [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&envId=dynamic-programming)

> **作者**：弘树
> **日期**：2024-09-22
> **所用时间**：11min

## 1. 动态规划

### 1.1 状态表示

可以分为2种情况，分别为$f[i][0]$和$f[i][1]$

对于$f[i][0]$来说：

1. $f[i][0][0]$表示在第$i$天进行完操作不持有股票同时购买股票次数为0的最大利润
2. $f[i][0][1]$表示在第$i$天进行完操作不持有股票同时购买股票次数为1的最大利润
3. ......
4. $f[i][0][k]$表示在第$i$天进行完操作不持有股票同时购买股票次数为k的最大利润

对于$f[i][1]$来说：

1. $f[i][1][0]$表示在第$i$天进行完操作不持有股票同时购买股票次数为0的最大利润
2. $f[i][1][1]$表示在第$i$天进行完操作不持有股票同时购买股票次数为1的最大利润
3. ......
4. $f[i][1][k - 1]$表示在第$i$天进行完操作持有股票同时购买股票次数为$k - 1$的最大利润

### 1.2 状态计算

#### 1.2.1 $f[i][0]$状态计算

若第$i$不持有股票，则有2种可能：

 - 第$i - 1$就没有股票，则

    $$f[i][0][0] = f[i - 1][0][0]$$

    $$f[i][0][1] = f[i - 1][0][1]$$

    $$……$$
    
    $$f[i][0][k] = f[i - 1][0][k]$$

  - 第$i - 1$持有股票，在第$i$天出售，则
  
    $$f[i][0][0] = f[i - 1][1][0] + prices[i]$$

    $$f[i][0][1] = f[i - 1][1][1] + prices[i]$$

    $$……$$

    $$f[i][0][k - 1] = f[i - 1][1][k - 1] + prices[i]$$


综上，当$j \in [0, k - 1]$时，$f[i][0][j]$的状态转移方程为：

$$
    f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j] + prices[i])
$$

当$j = k$时，$f[i][0][j]$的状态转移方程为：

$$
    f[i][0][k] = f[i - 1][0][k]
$$

#### 1.2.2 $f[i][1]$状态计算

若第$i$持有股票，则有2种可能：

  - 第$i - 1$就持有股票，则

    $$f[i][1][0] = f[i - 1][1][0]$$

    $$f[i][1][1] = f[i - 1][1][1]$$

    $$……$$

    $$f[i][1][k - 1] = f[i - 1][1][k - 1]$$

  - 第$i - 1$不持有股票，在第$i$天购买，则

    $$f[i][1][0] = f[i - 1][0][1] - prices[i]$$
    
    $$f[i][1][1] = f[i - 1][0][2] - prices[i]$$

    $$……$$

    $$f[i][1][k - 1] = f[i - 1][0][k] - prices[i]$$

对于$f[i][1]$的状态转移方程如下：

$$
    f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j + 1] - prices[i]), j \in [0, k - 1]
$$

最后答案为$\max(f[n][j]), j\in [0, k]$。

- 时间复杂度：$O(nk)$
- 空间复杂度：$O(2nk)$

```C++
class Solution {
public:
    long long f[1010][2][110];

    int maxProfit(int k, vector<int>& prices) {
        for (int i = 0; i < k; i ++) f[1][0][i] = INT_MIN;
        for (int i = 0; i < k - 1; i ++) f[1][1][i] = INT_MIN;
        f[1][0][k] = 0, f[1][1][k - 1] = -prices[0];
        for (int i = 2; i <= prices.size(); i ++)
        {
            for (int j = 0; j < k; j ++) 
                f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j] + prices[i - 1]);
            f[i][0][k] = f[i - 1][0][k];
            for (int j = 0; j < k; j ++)
                f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j + 1] - prices[i - 1]);
        }
        long long ans = 0;
        for (int i = 0; i <= k; i ++) ans = max(ans, f[prices.size()][0][i]);
        return ans;
    }
};
```

## 2. 滚动数组空间优化

可以发现第$i$个时刻的状态总依赖于第$i - 1$时刻的状态，所以可以使用$2k$个常量保存上一个时刻的状态，这里不再演示