# 91. 解码方法

> **作者:** 弘树
> **日期:** 2024-08-17
> **所用时间:** 30min

## 解题思路
### 1.动态规划

状态表示：

- $f[i][0]$表示前$i$个字符构成的字符串并且不解码$s[i]$的解码方法的总数
- $f[i][1]$表示前$i$个字符构成的字符串并且解码$s[i]$的解码方法的总数

状态计算：对于$f[i][0]$来说，若不解码$s[i]$，那么$s[i - 1]$必须解码，前提是s[i - 1]要满足能够解码的条件

$$
    f[i][0] = f[i - 1][1]
$$

---

状态转移方程不对....

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```C++
class Solution {
public:
    int f[110];

    int numDecodings(string s) {
        if (s[0] == '0') return 0;

        f[0] = f[1] = 1;
        for (int i = 1; i < s.size(); i ++)
        {
            if (s[i] == '0')
            {
                if (s[i - 1] == '1' || s[i - 1] == '2') f[i + 1] = f[i - 1];
                else return 0;
            } 
            else if (s[i - 1] == '1' || (s[i - 1] == '2' && '1' <= s[i] && s[i] <= '6')) 
                f[i + 1] = f[i] + f[i - 1];
            else f[i + 1] = f[i]; 
        }
        return f[s.size()];
    }
};
```