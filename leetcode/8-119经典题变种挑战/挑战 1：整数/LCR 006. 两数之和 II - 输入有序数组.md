# [LCR 006. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/kLl5u1/description/)

> **作者**：弘树
> **日期**：2024-10-07
> **所用时间**：3min

## 1. 对撞指针

### 1.1 解题思路

指针$l$从数组的最左端向右移动，指针$r$从数组的最右端向左移动，之后对两个指针所指向位置元素的和$s$进行判断：

1. 若$s = target$，返回$[l, r]$即为答案
2. 若$s \lq target$，需要增大$s$，由于数组是严格递增的，所以需要将指针$l$向右移动
3. 否则，将指针$r$向左移动

现在思考一个问题：为什么这么做是对的呢？

我个人理解是一种逐渐逼近的思想，一开始选择数组第一个元素和最后一个元素的和$s$作为标准进行判断：

1. 如果$s$大于$target$，那么我需要找到所有比$s$小的组合，由于数组是递增的，所以可以有两种操作：
   
   - 将指针$l$向左移动
   - 将指针$r$向左移动
  
  为什么这里选择移动指针$r$，而不移动指针$l$呢？

  我们这种做法有一个前提：指针$l$是只向右移动的，因此指针$l$一定是从$l-1$的位置移动过来的，由于一次只移动一个指针，所以在尝试$(l, r)$这种组合之前，一定尝试过了$(l - 1, r)$这个组合，之所以把指针$l$从$l - 1$移动到$l$，是因为
  
$$
    numbers[l - 1] + numbers[r] ＜ target
$$

  因此，我们只能将指针$r$向左移动以减小$s$。

2. 当$s$小于$target$时，分析和上面一样，只能将指针$l$向右移动

### 1.2 复杂度分析

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

### 1.3 代码实现

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers) - 1
        while numbers[l] + numbers[r] != target:
            if numbers[l] + numbers[r] < target:
                l += 1
            else:
                r -= 1
        return [l, r]
```